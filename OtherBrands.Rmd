---
title: "R Notebook"
output: html_notebook
---
Read in original data and new brand data
Then combine into single dataframe "diamonds" (matching TJ's naming)
Which now has a new column "vendor"
Original data file has value "vendor" == "Original"

```{r}
orig_diamonds= read.csv("diamonds4.csv")
orig_diamonds = data.frame(orig_diamonds)
orig_diamonds$vendor = "Original"

extra_diamonds= read.csv("extra_diamonds.csv")
extra_diamonds = data.frame(extra_diamonds)
keep_columns = c("carat","clarity","color","cut","price","vendor")
extra_diamonds = extra_diamonds[keep_columns]

diamonds <- rbind(extra_diamonds, orig_diamonds)

# preserve original values for price and carat, pre-transform
diamonds$o_price <- diamonds$price
diamonds$o_carat <- diamonds$carat
```

Simplify categories using TJ's code 

```{r}
library(MASS) 
library(dplyr)
#EDA for project

diamonds$clarity = factor(diamonds$clarity)
diamonds$cut= factor(diamonds$cut)
diamonds$color =factor(diamonds$color)

#levels(diamonds$clarity)
#levels(diamonds$cut)
#levels(diamonds$color)

#adjusting the data frame variables to the transformed versions
diamonds$price = log(diamonds$price)
diamonds$carat = log(diamonds$carat + .2)

###############################################
#### NOTE: I added "K" to colorgroup3
###############################################
##### setting new levels and reference levels
levels(diamonds$color) <- list("colorgroup1" = c("D"),
                      "colorgroup2"   = c("E","F","G","H"),
                      "colorgroup3"   = c("I","J","K"))

diamonds$color = relevel(diamonds$color, ref = "colorgroup3")
contrasts(diamonds$color)

###############################################
#### NOTE: I added "Excellent" to cutgroup2
###############################################
levels(diamonds$cut) <- list("cutgroup1" = c("Astor Ideal"),
                             "cutgroup2"   = c("Ideal", "Excellent"),
                             "cutgroup3"   = c("Good","Very Good"))

diamonds$cut = relevel(diamonds$cut, ref = "cutgroup3")
contrasts(diamonds$cut)

levels(diamonds$clarity) <- list("claritygroup1" = c("FL","IF"),
                                 "claritygroup2"   = c("VS1","VVS1","VS2","VVS2"),
                                 "claritygroup3"   = c("SI1","SI2"))

diamonds$clarity = relevel(diamonds$clarity, ref = "claritygroup3")
contrasts(diamonds$clarity)

```

Set aside the external vendors' diamonds into dataframe "subExtra"
Then remove them from our main "diamonds" dataframe
They will not influence our model and can be used for testing

After this code snippet, "diamonds" will contain the same data as the original
(except it has the new column "vendor")

```{r}
subCostco<-subset(diamonds,vendor=="Costco")
subCostco$subcolor = "coral3"
subCostco$subpch = 2
subBlueNile<-subset(diamonds,vendor=="BlueNile")
subBlueNile$subcolor = "blue"
subBlueNile$subpch = 12
subDanielWilliams<-subset(diamonds,vendor=="DanielWilliams")
subDanielWilliams$subcolor = "green"
subDanielWilliams$subpch = 8
subExtras <- rbind(subBlueNile, subCostco, subDanielWilliams)
#subExtras$brand = 
diamonds<-subset(diamonds,vendor=="Original")
```

See how Vendors' diamond data compares to original
Temporarily remove diamonds over 4.5 carats to better focus on
the Vendors' diamonds 

```{r}
diamonds_focused<-subset(diamonds,carat<4.5)
plot(diamonds_focused$carat,
     diamonds_focused$price, 
     col = "grey",
     main="Price against carat",
     ylab="Log(Price in dollars)",
     xlab="Log(Carats)")
points(subExtras$carat,subExtras$price, 
       pch=subExtras$subpch, 
       col=subExtras$subcolor)
legend("topleft", c("Original Data","Costco","Blue Nile","Daniel William"), lty=c(1,2,3,4),
       pch=c(1,2,12,8), 
       cex = 0.85,
       col=c("grey","coral3","blue","green"))
```

Create model (without any interactions)

```{r}
#model with all additive terms and condensed #classes
test_lm = lm(price~carat+cut+clarity+color, data=diamonds)
summary(test_lm)

```

An initial test of predictions


```{r}

pExtras <- data.frame(predict(test_lm, newdata = subExtras, interval = "prediction"))
subExtras$predicted <- exp(pExtras$fit)
#subExtras$log_range <- pExtras$upr - pExtras$lwr

#subExtras$gap <- (pExtras$fit - subExtras$price) / subExtras$price

subExtras

```

Show conf intervals here

```{r}
pred.int <- predict(test_lm, newdata = subExtras, interval = "prediction")

ggdata <- cbind(subExtras,pred.int)
library("ggplot2")

p <- ggplot(ggdata, aes(carat, price)) +
  geom_point(pch=subExtras$subpch, 
             col=subExtras$subcolor) 
p + geom_line(aes(y = lwr), color = "red", linetype = "dashed")+
  geom_line(aes(y = upr), color = "red", linetype = "dashed") +
  geom_line(aes(y = fit), color = "blue")
#  stat_smooth(method = "loess")  # "gam" and "lm" are other options

#NB I can't figure out how to make a legend :-(
```





Bar chart showing under/over counts

```{r}
subExtras$upr <- exp(pExtras$upr)
subExtras$lwr <- exp(pExtras$lwr)


subExtras$PAccuracy[subExtras$o_price < subExtras$lwr] = "Below PI"
subExtras$PAccuracy[subExtras$o_price >= subExtras$lwr] = "Low"
subExtras$PAccuracy[subExtras$o_price > (subExtras$predicted * 0.95)] = "Accurate"
subExtras$PAccuracy[subExtras$o_price >= (subExtras$predicted * 1.05)] = "High"
subExtras$PAccuracy[subExtras$o_price >= subExtras$upr] = "Above PI"

M <- c("Below PI", "Low", "Accurate", "High", "Above PI")
subExtras$PAccuracy <- factor(subExtras$PAccuracy, levels = M)
counts <- table(subExtras$PAccuracy, subExtras$vendor)
counts2 <- prop.table(counts, 2) # change counts to %
par(mfrow=c(1, 1), mar=c(5, 5, 4, 8))
barplot(counts2, main="Diamond Prices compared to Predicted Price",
  xlab="Diamond Seller",
  ylab="Sample Frequency",
  col=c("green","blue","yellow","orange","red"),
  names.arg=c("Blue\nNile","Costco\n","Daniel\nWilliam"),
  legend = rownames(counts),
  args.legend = list(x = "topright", bty = "n", inset=c(-0.5, 0)))
```


Attempt to plot PI's

```{r}
pred.int <- predict(test_lm, newdata = subExtras, interval = "prediction")

ggdata <- cbind(subExtras,pred.int)
library("ggplot2")

p <- ggplot(ggdata, aes(carat, price)) +
  geom_point(pch=subExtras$subpch, 
             col=subExtras$subcolor) 
p + geom_line(aes(y = lwr), color = "red", linetype = "dashed")+
  geom_line(aes(y = upr), color = "red", linetype = "dashed") +
  geom_line(aes(y = fit), color = "blue")
#  stat_smooth(method = "loess")  # "gam" and "lm" are other options

#NB I can't figure out how to make a legend :-(

```

'''
PriceAccuracy <- function(actual,
                          fitted,
                          p_lower,
                          p_upper) {
  lowAccurate <- fitted * 0.95
  highAccurate <- fitted * 1.05
  rval = "Below PI"
  if (actual > p_lower) { rval = "Low" }
  if (actual > lowAccurate) { rval = "Accurate" }
  if (actual > highAccurate) { rval = "High" }
  if (actual > p_upper) { rval = "Above PI" }
  cat(actual,fitted,p_lower,p_upper,rval,sep=" ")
  rval
}'''

